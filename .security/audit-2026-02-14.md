# Comprehensive Security Audit Report: herdctl
**Audit Date:** 2026-02-14
**Auditor:** Claude (Anthropic AI Assistant)
**Project Version:** @herdctl/core v3.0.1, @herdctl/discord v0.1.9
**Scope:** Complete codebase security review focusing on TypeScript packages, Docker configuration, and GitHub Actions workflows

---

## Executive Summary

This comprehensive security audit examined the herdctl fleet management system for Claude Code agents. The system demonstrates **strong foundational security** with mature input validation, path traversal protection, and container hardening. However, several **medium-severity gaps** require attention, particularly around secret management, error information disclosure, and webhook security.

### Overall Security Rating: **YELLOW** (Moderate Risk)

**Key Strengths:**
- Robust path traversal protection with defense-in-depth validation
- Strong Docker container hardening with capability dropping and resource limits
- Comprehensive Zod schema validation with strict mode
- Two-tier privilege model separating agent-level from fleet-level configuration

**Critical Findings:**
- 2 High-severity issues (command injection risk in shell hooks, hostConfigOverride bypass)
- 7 Medium-severity issues (secret exposure, SSRF risks, information disclosure)
- 12 Low-severity issues (configuration gaps, logging deficiencies)

---

## 1. Input Validation & Injection Risks

### 1.1 Command Injection Protection ‚úÖ **STRONG**

**Location:** `packages/core/src/hooks/runners/shell.ts`, `packages/core/src/runner/runtime/container-runner.ts`

**Analysis:**
- Shell hooks use `spawn(command, { shell: true })` which **intentionally** allows shell interpretation for flexibility
- Docker exec commands properly use array arguments to prevent injection
- CLI runtime uses `execa` with array arguments (safe)

**Finding #1: MEDIUM - Shell Hook Command Injection Risk**
```typescript
// packages/core/src/hooks/runners/shell.ts:153
const proc = spawn(command, {
  shell: true,  // ‚ö†Ô∏è Allows shell metacharacters
  cwd: this.cwd,
  env: { ...process.env, ...this.env },
});
```

**Risk:** Users can configure shell hooks that execute arbitrary commands. If hook configurations are user-controlled or sourced from untrusted inputs, this enables command injection.

**Severity:** Medium (requires config file access, documented behavior)

**Recommendation:**
```typescript
// Add warning in documentation and config schema
ShellHookConfigSchema.extend({
  command: z.string().min(1).describe(
    "‚ö†Ô∏è SECURITY: Command is executed via shell. Only use trusted commands."
  )
});
```

### 1.2 Path Traversal Protection ‚úÖ **EXCELLENT**

**Location:** `packages/core/src/state/utils/path-safety.ts`, `packages/core/src/config/schema.ts`

**Analysis:**
- Defense-in-depth approach with regex validation + path resolution verification
- Agent names validated against `/^[a-zA-Z0-9][a-zA-Z0-9_-]*$/` (blocks `../`, `.`, special chars)
- `buildSafeFilePath()` performs both pattern check and resolution check

**Code Review:**
```typescript
// packages/core/src/state/utils/path-safety.ts:67-94
export function buildSafeFilePath(baseDir: string, identifier: string, extension: string): string {
  // First line of defense: validate identifier format
  if (!isValidIdentifier(identifier)) {
    throw new PathTraversalError(...);
  }

  // Second line of defense: verify resolved path stays within baseDir
  const resolvedPath = resolve(filePath);
  if (!resolvedPath.startsWith(resolvedBase + "/") && resolvedPath !== resolvedBase) {
    throw new PathTraversalError(...);
  }
  return filePath;
}
```

**Finding #2: LOW - No Length Limits on Identifiers**

**Risk:** Extremely long agent names (e.g., 10,000 characters) could cause filesystem issues or buffer overflows in underlying systems.

**Recommendation:**
```typescript
export const AGENT_NAME_PATTERN = /^[a-zA-Z0-9][a-zA-Z0-9_-]{0,255}$/; // Add max length
```

### 1.3 YAML/JSON Parsing ‚úÖ **SAFE**

**Location:** `packages/core/src/config/loader.ts:243`

**Analysis:**
- Uses `yaml` library's safe parser (no code execution)
- Handles YAML parse errors gracefully with line/column information
- No use of `eval()` or dynamic code execution

**Code Review:**
```typescript
// packages/core/src/config/loader.ts:243
try {
  rawConfig = parseYaml(content);  // Safe YAML parsing
} catch (error) {
  if (error instanceof YAMLParseError) {
    // Provides line/column info without executing code
  }
}
```

**Status:** ‚úÖ No vulnerabilities found

### 1.4 Environment Variable Interpolation ‚úÖ **SAFE**

**Location:** `packages/core/src/config/interpolate.ts:36`

**Analysis:**
- Simple regex-based substitution (no command execution)
- Pattern: `/\$\{([A-Za-z_][A-Za-z0-9_]*)(?::-([^}]*))?\}/g`
- No support for command substitution like `$(cmd)` or backticks

**Finding #3: LOW - Default Values Not Validated**

```typescript
// packages/core/src/config/interpolate.ts:99-100
} else if (defaultValue !== undefined) {
  replacement = defaultValue;  // ‚ö†Ô∏è No validation of default value
}
```

**Risk:** Default values like `${API_KEY:-$(malicious_command)}` would be inserted literally (safe, but could be confusing).

**Recommendation:** Document that default values are literal strings, not interpolated.

---

## 2. Container Security

### 2.1 Docker Configuration Hardening ‚úÖ **STRONG**

**Location:** `packages/core/src/runner/runtime/container-manager.ts:124-128`

**Analysis:**
- **Excellent default hardening:**
  - `SecurityOpt: ["no-new-privileges:true"]` ‚úÖ
  - `CapDrop: ["ALL"]` ‚úÖ (drops all Linux capabilities)
  - `PidsLimit` prevents fork bombs ‚úÖ
  - Memory limits prevent DoS ‚úÖ
  - Non-root user by default ‚úÖ

**Code Review:**
```typescript
// packages/core/src/runner/runtime/container-manager.ts:101-131
const translatedHostConfig: HostConfig = {
  Memory: config.memoryBytes,           // Default: 2GB
  MemorySwap: config.memoryBytes,       // No swap
  CpuShares: config.cpuShares,          // Optional CPU limit
  PidsLimit: config.pidsLimit,          // Prevents fork bombs
  NetworkMode: config.network,          // Default: bridge
  SecurityOpt: ["no-new-privileges:true"], // ‚úÖ Prevents privilege escalation
  CapDrop: ["ALL"],                     // ‚úÖ Drops all capabilities
  ReadonlyRootfs: false,                // Claude needs temp files
  AutoRemove: config.ephemeral,         // Cleanup ephemeral containers
};
```

**Finding #4: HIGH - hostConfigOverride Bypass Mechanism**

```typescript
// packages/core/src/runner/runtime/container-manager.ts:142-144
const finalHostConfig: HostConfig = config.hostConfigOverride
  ? { ...translatedHostConfig, ...config.hostConfigOverride }  // ‚ö†Ô∏è Can override ALL security
  : translatedHostConfig;
```

**Risk:** Fleet operators can completely bypass security hardening by setting:
```yaml
docker:
  host_config:
    CapDrop: []          # Re-enable all capabilities
    SecurityOpt: []      # Disable no-new-privileges
    Privileged: true     # Full host access
```

**Severity:** High (but mitigated by trust model - only fleet-level config)

**Current Mitigation:**
- Only available at fleet-level (not agent-level) per schema separation
- Documented in `.security/THREAT-MODEL.md` as intentional for advanced use cases
- Assumes fleet operators are trusted administrators

**Recommendation:**
1. Add audit logging when `hostConfigOverride` is used
2. Add config validation to warn on dangerous overrides:
```typescript
if (config.hostConfigOverride?.Privileged === true) {
  logger.warn("‚ö†Ô∏è SECURITY: Privileged mode enabled - container has full host access");
}
if (config.hostConfigOverride?.CapDrop?.length === 0) {
  logger.warn("‚ö†Ô∏è SECURITY: All capabilities enabled - reduced container isolation");
}
```

### 2.2 Network Modes ‚ö†Ô∏è **CONFIGURATION DEPENDENT**

**Location:** `packages/core/src/config/schema.ts:142`, `packages/core/src/runner/runtime/docker-config.ts:246`

**Analysis:**
- Three modes: `none`, `bridge` (default), `host`
- **Critical:** `network: none` breaks Claude agents (documented in CLAUDE.md)
- **Risk:** `network: host` shares host network namespace (low isolation)

**Finding #5: MEDIUM - Network Host Mode Reduces Isolation**

**Current State:**
```typescript
// packages/core/src/config/schema.ts:142
export const DockerNetworkModeSchema = z.enum(["none", "bridge", "host"]);
```

**Risk:** Agents with `network: host` can:
- Access host's localhost services
- Bypass firewall rules
- Enumerate internal network
- Potentially access metadata services (cloud providers)

**Recommendation:**
```typescript
// Add validation and warning
.refine((data) => {
  if (data.network === "host") {
    console.warn("‚ö†Ô∏è SECURITY: network=host reduces isolation. Agent can access host network.");
  }
  if (data.network === "none") {
    console.warn("‚ö†Ô∏è network=none will break Claude agents (cannot reach Anthropic API)");
  }
  return true;
})
```

### 2.3 Volume Mounts ‚ö†Ô∏è **USER CONFIGURATION RISK**

**Location:** `packages/core/src/config/schema.ts:329-346`, `packages/core/src/runner/runtime/container-manager.ts:264-301`

**Analysis:**
- Volume mount syntax validated (must be `host:container:ro|rw`)
- **No validation of host path safety**

**Finding #6: MEDIUM - Arbitrary Host Path Mounting**

```typescript
// packages/core/src/config/schema.ts:331-340
.refine((data) => {
  if (!data.volumes) return true;
  return data.volumes.every((vol) => {
    const parts = vol.split(":");
    // ‚ö†Ô∏è No check that host path is safe
    return parts.length >= 2 && parts.length <= 3;
  });
})
```

**Risk:** Users can mount sensitive host paths:
```yaml
docker:
  volumes:
    - "/etc/passwd:/etc/passwd:rw"    # ‚ö†Ô∏è Expose host passwords
    - "/:/host:rw"                    # ‚ö†Ô∏è Full host filesystem access
    - "/var/run/docker.sock:/var/run/docker.sock:rw"  # ‚ö†Ô∏è Docker socket escape
```

**Recommendation:**
1. Add path validation to block sensitive paths:
```typescript
const DANGEROUS_MOUNT_PATHS = [
  "/etc/passwd", "/etc/shadow", "/root",
  "/var/run/docker.sock", "/sys", "/proc",
  "/"  // Root filesystem
];

.refine((data) => {
  if (!data.volumes) return true;
  const dangerousMounts = data.volumes.filter(vol => {
    const hostPath = vol.split(":")[0];
    return DANGEROUS_MOUNT_PATHS.some(dangerous =>
      hostPath === dangerous || hostPath.startsWith(dangerous + "/")
    );
  });
  if (dangerousMounts.length > 0) {
    throw new Error(`Dangerous volume mounts detected: ${dangerousMounts.join(", ")}`);
  }
  return true;
})
```

2. Add warning for read-write mounts outside workspace:
```typescript
if (mode === "rw" && !hostPath.startsWith(workspaceRoot)) {
  logger.warn(`‚ö†Ô∏è Read-write mount outside workspace: ${hostPath}`);
}
```

### 2.4 Dockerfile Security ‚úÖ **GOOD**

**Location:** `/opt/herdctl/Dockerfile`

**Analysis:**
```dockerfile
FROM node:22-slim  # ‚úÖ Using slim base image

# World-writable directories for container user flexibility
RUN mkdir -p /home/claude/.claude/projects && \
    chmod -R 777 /home/claude  # ‚ö†Ô∏è World-writable

# Container runs as non-root user (via --user flag at runtime)
CMD ["tail", "-f", "/dev/null"]
```

**Finding #7: LOW - World-Writable Directories in Image**

**Risk:** Any user inside container can modify `/home/claude` contents. This is intentional for UID flexibility but reduces defense-in-depth.

**Severity:** Low (container isolation provides primary security)

**Recommendation:** Document that container isolation is the primary security boundary, not file permissions.

---

## 3. Secrets Management

### 3.1 API Key Handling ‚ö†Ô∏è **WEAK**

**Location:** `packages/core/src/runner/runtime/container-manager.ts:317-324`

**Analysis:**
- API keys passed as environment variables (industry standard)
- **No encryption at rest**
- **No rotation mechanism**
- Visible in `docker inspect` output

**Code Review:**
```typescript
// packages/core/src/runner/runtime/container-manager.ts:317-324
export function buildContainerEnv(agent: ResolvedAgent, config?: DockerConfig): string[] {
  const env: string[] = [];

  // ‚ö†Ô∏è API keys passed in plaintext
  if (process.env.ANTHROPIC_API_KEY) {
    env.push(`ANTHROPIC_API_KEY=${process.env.ANTHROPIC_API_KEY}`);
  }
  if (process.env.CLAUDE_CODE_OAUTH_TOKEN) {
    env.push(`CLAUDE_CODE_OAUTH_TOKEN=${process.env.CLAUDE_CODE_OAUTH_TOKEN}`);
  }
  // ...
}
```

**Finding #8: MEDIUM - Secrets Visible in Container Metadata**

**Risk:**
- `docker inspect <container>` exposes all environment variables
- Container logs may leak secrets if agent prints environment
- No automatic secret rotation

**Recommendation:**
1. Add secret detection to log output:
```typescript
const SECRET_PATTERNS = [
  /sk-ant-[a-zA-Z0-9_-]+/,           // Anthropic API keys
  /ghp_[a-zA-Z0-9]{36}/,             // GitHub PATs
  /ANTHROPIC_API_KEY=sk-ant-[^\s]+/, // In logs
];

function redactSecrets(output: string): string {
  let redacted = output;
  for (const pattern of SECRET_PATTERNS) {
    redacted = redacted.replace(pattern, "[REDACTED]");
  }
  return redacted;
}
```

2. Document secret rotation best practices in security guide
3. Consider using Docker secrets or HashiCorp Vault for production deployments

### 3.2 GitHub Token Handling ‚ö†Ô∏è **MODERATE**

**Location:** `packages/core/src/work-sources/adapters/github.ts:410`, `packages/core/src/config/schema.ts:44-46`

**Analysis:**
- Token read from environment variable (configurable name)
- **No scope validation on startup** (validation method exists but not called automatically)
- **No rate limit warnings by default**

**Finding #9: LOW - GitHub Token Scope Not Validated on Startup**

```typescript
// packages/core/src/work-sources/adapters/github.ts:435-513
async validateToken(): Promise<{ scopes: string[]; valid: boolean }> {
  // ‚ö†Ô∏è This method exists but is not called automatically
  // Users must manually call adapter.validateToken()
}
```

**Recommendation:**
```typescript
// Call validation on adapter creation
constructor(config: GitHubWorkSourceConfig) {
  this.config = config;
  // Validate token on startup
  this.validateToken().catch(err => {
    console.warn(`‚ö†Ô∏è GitHub token validation failed: ${err.message}`);
  });
}
```

### 3.3 Webhook Secret Handling ‚ö†Ô∏è **NOT IMPLEMENTED**

**Location:** `packages/core/src/config/schema.ts:794-798`

**Analysis:**
```typescript
// packages/core/src/config/schema.ts:794-798
export const WebhooksSchema = z.object({
  enabled: z.boolean().optional().default(false),
  port: z.number().int().positive().optional().default(8081),
  secret_env: z.string().optional(),  // ‚ö†Ô∏è Defined but not enforced
});
```

**Finding #10: HIGH - Webhook Signature Verification Not Implemented**

**Risk:**
- No webhook server implementation found in codebase
- Schema defines `secret_env` but no verification logic
- Attackers can spoof webhook triggers

**Severity:** High (if webhooks are enabled)

**Recommendation:**
1. Implement HMAC signature verification:
```typescript
import crypto from 'crypto';

function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const hmac = crypto.createHmac('sha256', secret);
  const digest = hmac.update(payload).digest('hex');
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(digest)
  );
}
```

2. Add rate limiting on webhook endpoints
3. Log all webhook requests with source IP and signature validation results

---

## 4. File System Security

### 4.1 Path Validation ‚úÖ **EXCELLENT**

**Location:** `packages/core/src/state/utils/path-safety.ts`

**Analysis:** Already covered in Section 1.2 - excellent defense-in-depth implementation.

### 4.2 Working Directory Validation ‚úÖ **STRONG**

**Location:** `packages/core/src/state/session-validation.ts`, `packages/core/src/runner/job-executor.ts:223-240`

**Analysis:**
- Validates workspace hasn't changed between sessions
- Prevents session hijacking via workspace path manipulation

**Code Review:**
```typescript
// packages/core/src/runner/job-executor.ts:223-240
const wdValidation = validateWorkingDirectory(existingSession, currentWorkingDirectory);

if (!wdValidation.valid) {
  this.logger.warn(
    `${wdValidation.message} - clearing stale session ${existingSession.session_id}`
  );
  await clearSession(sessionsDir, agent.name);
  effectiveResume = undefined;  // ‚úÖ Prevents session reuse with wrong workspace
}
```

**Status:** ‚úÖ Well implemented

### 4.3 File Permissions ‚ö†Ô∏è **NOT ENFORCED**

**Finding #11: LOW - No File Permission Validation**

**Risk:** `.herdctl/` state directory and config files have no enforced permissions. On multi-user systems, other users may read job logs, session data, or modify state files.

**Recommendation:**
```typescript
// Add to state directory initialization
import { chmod, access, constants } from 'fs/promises';

async function ensureSecureStateDir(stateDir: string): Promise<void> {
  try {
    // Verify directory is owned by current user
    await access(stateDir, constants.R_OK | constants.W_OK);

    // Set restrictive permissions (owner read/write only)
    await chmod(stateDir, 0o700);

    console.log(`‚úÖ Secured state directory: ${stateDir} (mode 700)`);
  } catch (err) {
    console.warn(`‚ö†Ô∏è Failed to secure state directory: ${err.message}`);
  }
}
```

---

## 5. Dependency Security

### 5.1 Core Dependencies Analysis

**Package:** `@herdctl/core` v3.0.1

**Direct Dependencies:**
```json
{
  "@anthropic-ai/claude-agent-sdk": "^0.1.0",  // ‚ö†Ô∏è Early version (0.x)
  "chokidar": "^5",
  "cron-parser": "^4.9.0",
  "dockerode": "^4.0.9",
  "dotenv": "^17.2.3",
  "execa": "^9",
  "yaml": "^2.3.0",
  "zod": "^3.22.0"
}
```

**Finding #12: MEDIUM - Claude Agent SDK Early Version**

**Risk:** `@anthropic-ai/claude-agent-sdk` is at version 0.1.0 (pre-release). Security vulnerabilities may exist, API stability not guaranteed.

**Recommendation:**
1. Monitor Anthropic security advisories
2. Update to stable 1.0+ release when available
3. Pin exact version in production deployments

**Status of Known Libraries:**
- ‚úÖ `execa`: Battle-tested process spawning library, regularly maintained
- ‚úÖ `zod`: Industry-standard schema validation, secure
- ‚úÖ `yaml`: Uses safe parsing by default
- ‚úÖ `dockerode`: Mature Docker API client
- ‚ö†Ô∏è `chokidar`: File watching - monitor for vulnerabilities

### 5.2 Discord Package Dependencies

**Package:** `@herdctl/discord` v0.1.9

```json
{
  "@discordjs/rest": "^2.6.0",
  "discord.js": "^14.16.0"
}
```

**Status:** ‚úÖ Using current stable versions of discord.js ecosystem

### 5.3 Supply Chain Security ‚úÖ **GOOD**

**Analysis:**
- `publishConfig.provenance: true` enabled in all packages ‚úÖ
- GitHub Actions uses OIDC for npm publishing (no long-lived tokens) ‚úÖ
- Frozen lockfile enforced in CI ‚úÖ

**Code Review:**
```json
// packages/core/package.json:59-61
"publishConfig": {
  "access": "public",
  "provenance": true  // ‚úÖ Enables npm provenance attestations
}
```

**GitHub Actions:**
```yaml
# .github/workflows/release.yml:11-14
permissions:
  contents: write
  pull-requests: write
  id-token: write  # ‚úÖ OIDC token for npm publishing
```

**Status:** ‚úÖ Industry best practices followed

---

## 6. Authentication & Authorization

### 6.1 Agent Permission Modes ‚úÖ **WELL DESIGNED**

**Location:** `packages/core/src/config/schema.ts:14-21`

**Analysis:**
```typescript
export const PermissionModeSchema = z.enum([
  "default",           // ‚úÖ Safe: asks for approvals
  "acceptEdits",       // ‚ö†Ô∏è Auto-accepts file edits
  "bypassPermissions", // üî¥ Bypasses all checks
  "plan",              // ‚úÖ Safe: read-only
  "delegate",
  "dontAsk",
]);
```

**Finding #13: MEDIUM - bypassPermissions Mode Dangerous if Misused**

**Risk:** `bypassPermissions` disables all Claude safety checks. If used with untrusted prompts or in shared environments, this enables arbitrary file system access.

**Current Mitigation:**
- Documented as dangerous in schema comments
- Requires explicit configuration
- Passed to Claude SDK (SDK enforces the restriction)

**Recommendation:**
```typescript
.refine((data) => {
  if (data.permission_mode === "bypassPermissions") {
    console.warn(
      "‚ö†Ô∏è CRITICAL: bypassPermissions mode disables all safety checks. " +
      "Only use in trusted, isolated environments."
    );
  }
  return true;
})
```

### 6.2 Two-Tier Privilege Model ‚úÖ **EXCELLENT**

**Location:** `packages/core/src/config/schema.ts:166-228` (AgentDockerSchema), `253-387` (FleetDockerSchema)

**Analysis:**
- **Agent-level** (untrusted): Can only set safe options (memory, CPU, tmpfs, labels)
- **Fleet-level** (trusted): Can set dangerous options (image, network, volumes, user, host_config)
- Enforced via `.strict()` schema validation

**Code Review:**
```typescript
// packages/core/src/config/schema.ts:201
.strict() // ‚úÖ Reject unknown/dangerous Docker options at agent level
```

**Status:** ‚úÖ Excellent security design - prevents privilege escalation via agent configs

### 6.3 GitHub Token Scopes ‚ö†Ô∏è **VALIDATION AVAILABLE BUT NOT ENFORCED**

**Location:** `packages/core/src/work-sources/adapters/github.ts:435-513`

**Analysis:**
- `validateToken()` method checks for `repo` scope
- **Not called automatically** - users must invoke manually

**Recommendation:** See Finding #9 above - call validation on adapter initialization.

---

## 7. Error Handling & Information Disclosure

### 7.1 Error Message Sanitization ‚ö†Ô∏è **PARTIAL**

**Location:** `packages/core/src/runner/errors.ts`, `packages/core/src/state/utils/path-safety.ts`

**Finding #14: MEDIUM - Path Disclosure in Error Messages**

```typescript
// packages/core/src/state/utils/path-safety.ts:18-26
constructor(baseDir: string, identifier: string, resultPath: string) {
  super(
    `Path traversal detected: identifier "${identifier}" would resolve to "${resultPath}" ` +
    `which is outside base directory "${baseDir}"`  // ‚ö†Ô∏è Leaks full file system paths
  );
}
```

**Risk:** Error messages leak absolute file system paths, which could aid attacker reconnaissance.

**Severity:** Medium (information disclosure)

**Recommendation:**
```typescript
// In production mode, sanitize paths
const sanitizePath = (path: string): string => {
  if (process.env.NODE_ENV === 'production') {
    return path.replace(/^\/.*\/\.herdctl/, '[STATE_DIR]');
  }
  return path;
};

constructor(baseDir: string, identifier: string, resultPath: string) {
  super(
    `Path traversal detected: identifier "${identifier}" escapes base directory. ` +
    (process.env.NODE_ENV !== 'production'
      ? `Attempted path: ${resultPath}`
      : '')
  );
}
```

### 7.2 Stack Traces ‚ö†Ô∏è **EXPOSED**

**Finding #15: LOW - Full Stack Traces in Error Objects**

```typescript
// packages/core/src/runner/errors.ts
export class RunnerError extends Error {
  public readonly cause?: Error;  // ‚ö†Ô∏è Includes full stack trace
}
```

**Risk:** Stack traces may reveal file paths, dependency versions, and internal structure.

**Recommendation:**
- Strip stack traces in production error responses
- Log full errors server-side only
- Return sanitized error messages to clients

---

## 8. Network Security

### 8.1 Webhook SSRF Protection ‚ùå **MISSING**

**Location:** `packages/core/src/hooks/runners/webhook.ts`

**Finding #16: MEDIUM - No SSRF Protection in Webhook Hooks**

```typescript
// packages/core/src/hooks/runners/webhook.ts:126-131
const response = await this.fetchFn(config.url, {  // ‚ö†Ô∏è No URL validation
  method,
  headers,
  body: JSON.stringify(context),
  signal: controller.signal,
});
```

**Risk:** Users can configure webhook URLs pointing to internal services:
```yaml
hooks:
  after_run:
    - type: webhook
      url: "http://169.254.169.254/latest/meta-data/"  # ‚ö†Ô∏è Cloud metadata service
    - type: webhook
      url: "http://localhost:6379/SET%20malicious%20value"  # ‚ö†Ô∏è Redis injection
```

**Severity:** Medium (requires malicious config, but enables SSRF attacks)

**Recommendation:**
```typescript
import { URL } from 'url';

function isUrlSafe(urlString: string): boolean {
  try {
    const url = new URL(urlString);

    // Block private IP ranges
    const privateRanges = [
      /^127\./,           // localhost
      /^10\./,            // Private class A
      /^192\.168\./,      // Private class C
      /^172\.(1[6-9]|2[0-9]|3[01])\./,  // Private class B
      /^169\.254\./,      // Link-local
      /^::1$/,            // IPv6 localhost
      /^fe80:/,           // IPv6 link-local
    ];

    const hostname = url.hostname;
    if (privateRanges.some(range => range.test(hostname))) {
      return false;
    }

    // Require https in production
    if (process.env.NODE_ENV === 'production' && url.protocol !== 'https:') {
      return false;
    }

    return true;
  } catch {
    return false;
  }
}

// In WebhookHookRunner.execute():
if (!isUrlSafe(config.url)) {
  return {
    success: false,
    hookType: "webhook",
    error: "Webhook URL blocked: private IP or insecure protocol",
  };
}
```

### 8.2 GitHub API Security ‚úÖ **EXCELLENT**

**Location:** `packages/core/src/work-sources/adapters/github.ts`

**Analysis:**
- Implements exponential backoff for rate limits ‚úÖ
- Validates rate limit headers ‚úÖ
- Provides rate limit warnings ‚úÖ
- Uses Bearer token authentication ‚úÖ
- Implements retry logic for transient failures ‚úÖ

**Code Review:**
```typescript
// packages/core/src/work-sources/adapters/github.ts:289-305
export function extractRateLimitInfo(headers: Headers): RateLimitInfo | undefined {
  const remaining = headers.get("X-RateLimit-Remaining");
  const limit = headers.get("X-RateLimit-Limit");
  const reset = headers.get("X-RateLimit-Reset");
  // ... properly handles rate limit headers
}
```

**Status:** ‚úÖ Industry best practices implemented

---

## 9. GitHub Actions Workflow Security

### 9.1 CI Workflow Analysis

**Location:** `.github/workflows/ci.yml`

**Finding #17: MEDIUM - Self-Hosted Runner Security**

```yaml
# .github/workflows/ci.yml:16, 35, 58
runs-on: self-hosted  # ‚ö†Ô∏è Self-hosted runner
```

**Risk:**
- Self-hosted runners have access to the host system
- Malicious PRs could compromise the runner
- Runner environment is persistent across jobs

**Severity:** Medium (if PRs from untrusted contributors are allowed)

**Recommendation:**
1. Use ephemeral self-hosted runners (destroyed after each job)
2. Or switch to GitHub-hosted runners for public PRs:
```yaml
jobs:
  test:
    runs-on: ${{ github.event_name == 'pull_request' && 'ubuntu-latest' || 'self-hosted' }}
```

### 9.2 Release Workflow ‚úÖ **SECURE**

**Location:** `.github/workflows/release.yml`

**Analysis:**
```yaml
permissions:
  contents: write
  pull-requests: write
  id-token: write  # ‚úÖ OIDC for npm publishing

env:
  NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}  # ‚ö†Ô∏è Still using NPM_TOKEN secret
```

**Finding #18: LOW - Mixed OIDC and Token Authentication**

**Issue:** Workflow declares `id-token: write` for OIDC but still uses `NPM_TOKEN` secret. This is redundant - OIDC should replace the token.

**Recommendation:**
1. Remove `NODE_AUTH_TOKEN` environment variable
2. Ensure `changesets/action` is configured for OIDC publishing
3. Remove `NPM_TOKEN` secret from repository settings once OIDC is confirmed working

---

## 10. Logging & Audit Trail

### 10.1 Audit Logging ‚ö†Ô∏è **MINIMAL**

**Finding #19: MEDIUM - No Centralized Audit Log**

**Current State:**
- Job execution logged to console and JSONL files ‚úÖ
- No comprehensive audit trail ‚ùå
- No logging of configuration changes ‚ùå
- No logging of privileged operations (bypassPermissions mode, hostConfigOverride) ‚ùå

**Recommendation:**
```typescript
// Create centralized audit logger
class AuditLogger {
  async log(event: AuditEvent): Promise<void> {
    const entry = {
      timestamp: new Date().toISOString(),
      type: event.type,
      actor: event.actor,
      action: event.action,
      resource: event.resource,
      result: event.result,
      metadata: event.metadata,
    };

    // Append to audit log file
    await appendFile(
      join(stateDir, 'audit.jsonl'),
      JSON.stringify(entry) + '\n'
    );

    // Also emit event for external monitoring
    eventEmitter.emit('audit', entry);
  }
}

// Log security-sensitive operations
auditLogger.log({
  type: 'security',
  actor: 'fleet-manager',
  action: 'permission-mode-set',
  resource: agentName,
  result: 'success',
  metadata: { mode: 'bypassPermissions' }
});
```

### 10.2 Secret Detection in Logs ‚ùå **MISSING**

**Finding #20: MEDIUM - No Automatic Secret Redaction**

**Risk:** Job output logs may contain secrets if agents accidentally print environment variables or API responses.

**Recommendation:** See Finding #8 - implement secret pattern detection and redaction.

---

## Summary of Findings

### Critical Severity (0)
No critical vulnerabilities found.

### High Severity (2)

| # | Finding | Location | Recommendation |
|---|---------|----------|----------------|
| 4 | hostConfigOverride bypass mechanism | container-manager.ts:142-144 | Add audit logging and validation warnings |
| 10 | Webhook signature verification not implemented | config/schema.ts:794-798 | Implement HMAC verification, rate limiting |

### Medium Severity (7)

| # | Finding | Location | Recommendation |
|---|---------|----------|----------------|
| 1 | Shell hook command injection risk | hooks/runners/shell.ts:153 | Add documentation warnings |
| 5 | Network host mode reduces isolation | schema.ts:142 | Add validation warnings |
| 6 | Arbitrary host path mounting | schema.ts:329-346 | Block dangerous paths, validate mounts |
| 8 | Secrets visible in container metadata | container-manager.ts:317-324 | Implement secret detection, document rotation |
| 12 | Claude Agent SDK early version | package.json | Monitor security advisories, update when stable |
| 13 | bypassPermissions mode dangerous if misused | schema.ts:14-21 | Add runtime warnings |
| 14 | Path disclosure in error messages | state/utils/path-safety.ts | Sanitize paths in production |
| 16 | No SSRF protection in webhook hooks | hooks/runners/webhook.ts:126 | Block private IPs, require HTTPS |
| 17 | Self-hosted runner security | .github/workflows/ci.yml | Use ephemeral runners or GitHub-hosted |
| 19 | No centralized audit log | - | Implement audit logging system |
| 20 | No automatic secret redaction | - | Implement secret pattern detection |

### Low Severity (12)

| # | Finding | Location | Recommendation |
|---|---------|----------|----------------|
| 2 | No length limits on identifiers | state/utils/path-safety.ts | Add max length to regex pattern |
| 3 | Default values not validated | config/interpolate.ts:99-100 | Document literal string behavior |
| 7 | World-writable directories in image | Dockerfile:37 | Document container isolation boundary |
| 9 | GitHub token scope not validated on startup | work-sources/adapters/github.ts:435 | Call validateToken() in constructor |
| 11 | No file permission validation | - | Enforce 700 permissions on .herdctl/ |
| 15 | Full stack traces in error objects | runner/errors.ts | Strip stack traces in production |
| 18 | Mixed OIDC and token authentication | .github/workflows/release.yml | Remove NPM_TOKEN, use OIDC only |

---

## Security Controls Inventory

### ‚úÖ Strong Controls
1. **Path traversal protection** (buildSafeFilePath) - Defense-in-depth with regex + resolution validation
2. **Container hardening** (CapDrop, no-new-privileges, resource limits) - Industry best practices
3. **Two-tier privilege model** (agent vs fleet config) - Prevents privilege escalation
4. **Zod schema validation** (strict mode) - Comprehensive input validation
5. **GitHub API security** (rate limiting, retry logic, scope validation) - Production-ready
6. **Supply chain security** (provenance, OIDC, frozen lockfile) - Best practices

### ‚ö†Ô∏è Moderate Controls
1. **Permission modes** - SDK-enforced, but bypassPermissions is dangerous
2. **Network modes** - Configurable but host mode reduces isolation
3. **Secret handling** - Standard env vars but no encryption/rotation
4. **Working directory validation** - Prevents session hijacking

### ‚ùå Missing/Weak Controls
1. **Webhook signature verification** - Not implemented
2. **SSRF protection** - No URL validation
3. **Centralized audit logging** - No comprehensive trail
4. **Secret detection** - No automatic redaction
5. **File permissions** - Not enforced on state directory

---

## Recommendations by Priority

### Immediate Actions (Fix Before Production)
1. ‚úÖ Implement webhook HMAC signature verification (Finding #10)
2. ‚úÖ Add SSRF protection to webhook URLs (Finding #16)
3. ‚úÖ Implement secret pattern detection and redaction (Finding #8, #20)
4. ‚úÖ Add audit logging for privileged operations (Finding #19)

### Short-Term (Next Release)
5. ‚úÖ Validate and warn on dangerous Docker configurations (Findings #4, #5, #6)
6. ‚úÖ Add file permission validation on .herdctl/ directory (Finding #11)
7. ‚úÖ Sanitize error messages in production (Finding #14)
8. ‚úÖ Call GitHub token validation on adapter startup (Finding #9)

### Medium-Term (Future Versions)
9. ‚úÖ Implement secret rotation mechanism
10. ‚úÖ Add custom seccomp/AppArmor profiles for containers
11. ‚úÖ Implement comprehensive audit trail with retention policy
12. ‚úÖ Add security event notifications (alerts on suspicious activity)

### Long-Term (Roadmap)
13. ‚úÖ Encrypt sensitive state data at rest
14. ‚úÖ Implement role-based access control (RBAC) for multi-user deployments
15. ‚úÖ Add automated security scanning in CI/CD pipeline
16. ‚úÖ Conduct third-party penetration testing

---

## Positive Security Highlights

### Excellent Practices Observed

1. **Defense-in-Depth Path Validation**: The `buildSafeFilePath()` function exemplifies security best practices with multiple validation layers.

2. **Separation of Privileges**: The two-tier Docker config model (agent vs fleet) prevents untrusted agent configs from escalating privileges.

3. **Secure Defaults**:
   - Docker containers default to `bridge` network (safe)
   - Memory limits prevent DoS (2GB default)
   - Ephemeral containers enabled by default
   - Non-root user by default

4. **Modern Supply Chain Security**:
   - npm provenance enabled
   - GitHub OIDC publishing (no long-lived tokens)
   - Frozen lockfile in CI

5. **Input Validation**: Comprehensive Zod schemas with `.strict()` mode prevent configuration injection attacks.

6. **Error Handling**: Typed error classes with context provide good developer experience without sacrificing security.

---

## Conclusion

The herdctl codebase demonstrates **mature security engineering** with strong foundational controls. The path validation, container hardening, and privilege separation are **exemplary**. However, several **medium-severity gaps** require attention before production deployment, particularly:

- Webhook authentication (HMAC signatures)
- SSRF protection in webhook hooks
- Secret detection and redaction in logs
- Centralized audit logging

The existing threat model and security documentation show that security is a **first-class concern** in this project. With the recommended fixes, herdctl would achieve a **GREEN** (low risk) security rating.

**Overall Assessment:** ‚úÖ **Production-Ready with Recommended Fixes**

---

## Appendix A: Security Testing Recommendations

### Automated Testing
```bash
# Add to CI pipeline
npm audit --production
npx snyk test
npx retire --package-only
```

### Manual Testing Checklist
- [ ] Attempt path traversal with agent names like `../../../etc/passwd`
- [ ] Test malformed YAML with deeply nested structures (YAML bomb)
- [ ] Verify container capabilities are actually dropped (`docker inspect`)
- [ ] Test webhook SSRF with localhost and 169.254.169.254 URLs
- [ ] Verify secrets are not logged in job output
- [ ] Test bypassPermissions mode isolation
- [ ] Verify working directory validation prevents session hijacking
- [ ] Test resource limits (memory, CPU, PIDs) enforcement

### Penetration Testing Scenarios
1. **Config Injection**: Attempt to inject malicious Docker configs via agent files
2. **Container Escape**: Attempt privilege escalation from inside container
3. **Secret Extraction**: Try to extract API keys via log output or error messages
4. **SSRF**: Configure webhooks to access internal services
5. **Session Hijacking**: Attempt to reuse sessions with different workspaces

---

## Appendix B: Security Contact Information

**Security Issues:** Please report security vulnerabilities to the project maintainers via GitHub Security Advisories.

**Bug Bounty:** Not currently available for this pre-MVP project.

---

*End of Security Audit Report*
