---
phase: 03-docker-integration
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - packages/core/src/runner/runtime/factory.ts
  - packages/core/src/state/manager.ts
autonomous: true

must_haves:
  truths:
    - "RuntimeFactory wraps runtime with ContainerRunner when agent.docker.enabled is true"
    - "Docker sessions are stored in .herdctl/docker-sessions/ separate from host sessions"
    - "Agent with docker.enabled: true executes inside Docker container transparently"
  artifacts:
    - path: "packages/core/src/runner/runtime/factory.ts"
      provides: "RuntimeFactory with Docker wrapping"
      contains: "ContainerRunner"
  key_links:
    - from: "packages/core/src/runner/runtime/factory.ts"
      to: "packages/core/src/runner/runtime/container-runner.ts"
      via: "wraps runtime with ContainerRunner"
      pattern: "new ContainerRunner"
    - from: "packages/core/src/runner/runtime/factory.ts"
      to: "packages/core/src/runner/runtime/docker-config.ts"
      via: "uses resolveDockerConfig"
      pattern: "resolveDockerConfig"
---

<objective>
Integrate ContainerRunner into RuntimeFactory and ensure docker-sessions directory management.

Purpose: This plan completes the Docker integration by updating RuntimeFactory to wrap runtimes with ContainerRunner when docker.enabled is true. It also ensures the docker-sessions directory is properly managed for session isolation.

Output: Updated RuntimeFactory that transparently adds Docker containerization to any runtime.
</objective>

<execution_context>
@/Users/ed/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ed/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-docker-integration/03-CONTEXT.md
@.planning/phases/03-docker-integration/03-RESEARCH.md
@.planning/phases/03-docker-integration/03-01-SUMMARY.md
@.planning/phases/03-docker-integration/03-02-SUMMARY.md
@packages/core/src/runner/runtime/factory.ts
@packages/core/src/runner/runtime/container-runner.ts
@packages/core/src/runner/runtime/docker-config.ts
@packages/core/src/state/manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update RuntimeFactory to wrap with ContainerRunner</name>
  <files>packages/core/src/runner/runtime/factory.ts</files>
  <action>
Update RuntimeFactory.create() to wrap the base runtime with ContainerRunner when docker is enabled.

The factory needs to:
1. Create the base runtime (SDK or CLI) as before
2. Check if agent.docker?.enabled is true
3. If enabled, resolve docker config and wrap with ContainerRunner
4. Return the (possibly wrapped) runtime

Update the file:

```typescript
/**
 * Runtime factory for creating runtime instances
 *
 * Creates appropriate runtime implementations based on agent configuration.
 * Supports SDK runtime, CLI runtime, and optional Docker containerization.
 */

import type { ResolvedAgent } from "../../config/index.js";
import type { RuntimeInterface } from "./interface.js";
import { SDKRuntime } from "./sdk-runtime.js";
import { CLIRuntime } from "./cli-runtime.js";
import { ContainerRunner } from "./container-runner.js";
import { resolveDockerConfig } from "./docker-config.js";

/**
 * Runtime type identifier
 *
 * - 'sdk': Claude Agent SDK runtime (default, standard pricing)
 * - 'cli': Claude CLI runtime (Max plan pricing)
 */
export type RuntimeType = "sdk" | "cli";

/**
 * Options for runtime factory
 */
export interface RuntimeFactoryOptions {
  /**
   * herdctl state directory (.herdctl/)
   *
   * Required when Docker is enabled to locate docker-sessions directory.
   * If not provided, defaults to '.herdctl' in current working directory.
   */
  stateDir?: string;
}

/**
 * Runtime factory for creating runtime instances
 *
 * This factory creates the appropriate runtime implementation based on
 * agent configuration. It provides a centralized point for runtime
 * instantiation and validation.
 *
 * When docker.enabled is true, the base runtime is wrapped with
 * ContainerRunner for Docker containerization.
 *
 * @example
 * ```typescript
 * // SDK runtime (default)
 * const runtime = RuntimeFactory.create(resolvedAgent);
 *
 * // CLI runtime with Docker
 * const dockerRuntime = RuntimeFactory.create(dockerAgent, {
 *   stateDir: '/path/to/.herdctl'
 * });
 * ```
 */
export class RuntimeFactory {
  /**
   * Create a runtime instance based on agent configuration
   *
   * Determines the runtime type from agent.runtime (defaults to 'sdk')
   * and wraps with ContainerRunner if agent.docker.enabled is true.
   *
   * @param agent - Resolved agent configuration
   * @param options - Factory options including stateDir for Docker
   * @returns Runtime implementation (possibly wrapped with ContainerRunner)
   * @throws Error if runtime type is unsupported or invalid
   */
  static create(
    agent: ResolvedAgent,
    options: RuntimeFactoryOptions = {}
  ): RuntimeInterface {
    // Determine runtime type from agent config (default to SDK)
    const runtimeType: RuntimeType = (agent.runtime as RuntimeType) ?? "sdk";

    let runtime: RuntimeInterface;

    switch (runtimeType) {
      case "sdk":
        runtime = new SDKRuntime();
        break;

      case "cli":
        runtime = new CLIRuntime();
        break;

      default:
        throw new Error(
          `Unknown runtime type: ${runtimeType}. ` +
            "Supported types: 'sdk' (default), 'cli'"
        );
    }

    // Wrap with ContainerRunner if Docker is enabled
    if (agent.docker?.enabled) {
      const dockerConfig = resolveDockerConfig(agent.docker);
      const stateDir = options.stateDir ?? process.cwd() + "/.herdctl";

      runtime = new ContainerRunner(runtime, dockerConfig, stateDir);
    }

    return runtime;
  }
}
```

Key changes:
1. Added import for ContainerRunner and resolveDockerConfig
2. Added RuntimeFactoryOptions interface with stateDir
3. Updated create() to accept options parameter
4. Added Docker wrapping logic after base runtime creation
5. Updated JSDoc with Docker example
  </action>
  <verify>
Run `pnpm build` from packages/core - factory.ts should compile.
Verify RuntimeFactory signature accepts options parameter.
  </verify>
  <done>
RuntimeFactory.create() wraps base runtime with ContainerRunner when agent.docker.enabled is true.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update call sites to pass stateDir</name>
  <files>packages/core/src/fleet-manager/job-control.ts, packages/core/src/fleet-manager/schedule-executor.ts, packages/core/src/scheduler/schedule-runner.ts</files>
  <action>
Update all RuntimeFactory.create() call sites to pass stateDir option.

Search for all usages of RuntimeFactory.create() and update them to pass the stateDir from the calling context.

In fleet-manager/job-control.ts:
```typescript
// Find the RuntimeFactory.create(agent) call and update to:
const runtime = RuntimeFactory.create(agent, {
  stateDir: this.stateManager.stateDir,  // or however stateDir is accessed
});
```

In fleet-manager/schedule-executor.ts:
```typescript
// Find the RuntimeFactory.create(agent) call and update to:
const runtime = RuntimeFactory.create(agent, {
  stateDir: this.stateDir,  // or however stateDir is accessed
});
```

In scheduler/schedule-runner.ts:
```typescript
// Find the RuntimeFactory.create(agent) call and update to:
const runtime = RuntimeFactory.create(agent, {
  stateDir: options.stateDir,  // or however stateDir is accessed in this context
});
```

The exact property names depend on how each module accesses the state directory. Check each file to find the correct property:
- It might be `this.stateDir`
- It might be `this.stateManager.stateDir`
- It might be passed in options

If stateDir is not currently available in a context, add it to the constructor or options as needed.
  </action>
  <verify>
Run `pnpm build` from packages/core - all call sites should compile.
Verify RuntimeFactory calls include stateDir option.
  </verify>
  <done>
All RuntimeFactory.create() call sites pass stateDir option for Docker session management.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add docker-sessions directory initialization</name>
  <files>packages/core/src/state/manager.ts</files>
  <action>
Update StateManager to initialize the docker-sessions directory alongside other state directories.

Find where the StateManager initializes directories (likely in constructor or an init() method) and add docker-sessions:

```typescript
// Add to directory initialization
const dockerSessionsDir = path.join(this.stateDir, 'docker-sessions');
await fs.mkdir(dockerSessionsDir, { recursive: true });
```

Also add a getter for the docker-sessions directory path:

```typescript
/**
 * Get the docker-sessions directory path
 *
 * Docker containers store session files here, isolated from host sessions.
 */
get dockerSessionsDir(): string {
  return path.join(this.stateDir, 'docker-sessions');
}
```

If StateManager doesn't exist or has a different structure, create the initialization logic in the appropriate location where state directories are managed.
  </action>
  <verify>
Run `pnpm build` from packages/core - state/manager.ts should compile.
Verify docker-sessions directory is created in state initialization.
  </verify>
  <done>
StateManager initializes docker-sessions directory and provides dockerSessionsDir getter.
  </done>
</task>

</tasks>

<verification>
After all tasks:

1. `pnpm build` in packages/core succeeds
2. `pnpm typecheck` succeeds
3. RuntimeFactory wraps runtime with ContainerRunner when docker.enabled is true
4. All RuntimeFactory.create() call sites pass stateDir option
5. docker-sessions directory is initialized by StateManager
6. Docker configuration flows correctly: agent.docker -> resolveDockerConfig -> ContainerRunner
</verification>

<success_criteria>
- Agent with docker.enabled: true is wrapped in ContainerRunner by RuntimeFactory
- stateDir is passed to RuntimeFactory from all call sites
- docker-sessions directory is created during state initialization
- End-to-end: agent config with docker.enabled causes execution inside Docker container
- All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-docker-integration/03-03-SUMMARY.md`
</output>
