---
phase: 03-docker-integration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - packages/core/src/runner/runtime/container-runner.ts
  - packages/core/src/runner/runtime/container-manager.ts
autonomous: true

must_haves:
  truths:
    - "ContainerRunner wraps any RuntimeInterface and executes inside Docker containers"
    - "Containers mount workspace, auth files, and session directories with correct permissions"
    - "Container cleanup removes oldest containers when max_containers limit is exceeded"
  artifacts:
    - path: "packages/core/src/runner/runtime/container-runner.ts"
      provides: "ContainerRunner decorator implementing RuntimeInterface"
      exports: ["ContainerRunner"]
    - path: "packages/core/src/runner/runtime/container-manager.ts"
      provides: "Container lifecycle management"
      exports: ["ContainerManager", "createSecureContainer"]
  key_links:
    - from: "packages/core/src/runner/runtime/container-runner.ts"
      to: "packages/core/src/runner/runtime/interface.ts"
      via: "implements RuntimeInterface"
      pattern: "implements RuntimeInterface"
    - from: "packages/core/src/runner/runtime/container-runner.ts"
      to: "packages/core/src/runner/runtime/docker-config.ts"
      via: "uses DockerConfig for configuration"
      pattern: "DockerConfig"
---

<objective>
Implement ContainerRunner decorator that wraps any runtime and executes inside Docker containers.

Purpose: ContainerRunner is the core Docker integration component. It implements RuntimeInterface and wraps another runtime (SDK or CLI), transparently executing jobs inside Docker containers while handling path translation, mount configuration, and container lifecycle.

Output: container-runner.ts (decorator class) and container-manager.ts (lifecycle management).
</objective>

<execution_context>
@/Users/ed/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ed/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-docker-integration/03-CONTEXT.md
@.planning/phases/03-docker-integration/03-RESEARCH.md
@.planning/phases/03-docker-integration/03-01-SUMMARY.md
@packages/core/src/runner/runtime/interface.ts
@packages/core/src/runner/runtime/docker-config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create container-manager.ts for lifecycle management</name>
  <files>packages/core/src/runner/runtime/container-manager.ts</files>
  <action>
Create container-manager.ts with container creation and cleanup logic using dockerode.

First, install dockerode:
```bash
cd packages/core && pnpm add dockerode && pnpm add -D @types/dockerode
```

Then create the file:

```typescript
/**
 * Docker container lifecycle management
 *
 * Handles container creation, security configuration, and cleanup.
 * Uses dockerode for Docker API communication.
 */

import Docker from "dockerode";
import type { Container, ContainerCreateOptions } from "dockerode";
import * as path from "node:path";
import * as os from "node:os";
import type { DockerConfig, PathMapping } from "./docker-config.js";
import type { ResolvedAgent } from "../../config/index.js";

/**
 * Container manager for herdctl Docker execution
 */
export class ContainerManager {
  private docker: Docker;
  private runningContainers = new Map<string, Container>();

  constructor(docker?: Docker) {
    this.docker = docker ?? new Docker();
  }

  /**
   * Get or create a container for an agent
   *
   * For persistent containers (ephemeral: false), reuses existing running container.
   * For ephemeral containers, always creates a new container with AutoRemove.
   *
   * @param agentName - Name of the agent
   * @param config - Docker configuration
   * @param mounts - Volume mounts
   * @param env - Environment variables
   * @returns Docker container
   */
  async getOrCreateContainer(
    agentName: string,
    config: DockerConfig,
    mounts: PathMapping[],
    env: string[]
  ): Promise<Container> {
    // For persistent containers, check if already running
    if (!config.ephemeral) {
      const existing = this.runningContainers.get(agentName);
      if (existing) {
        try {
          const info = await existing.inspect();
          if (info.State.Running) {
            return existing;
          }
        } catch {
          // Container no longer exists, remove from map
          this.runningContainers.delete(agentName);
        }
      }
    }

    // Create new container
    const container = await this.createContainer(agentName, config, mounts, env);

    // Start the container
    await container.start();

    // Track persistent containers
    if (!config.ephemeral) {
      this.runningContainers.set(agentName, container);
    }

    return container;
  }

  /**
   * Create a new Docker container with security hardening
   */
  private async createContainer(
    agentName: string,
    config: DockerConfig,
    mounts: PathMapping[],
    env: string[]
  ): Promise<Container> {
    const containerName = `herdctl-${agentName}-${Date.now()}`;

    const createOptions: ContainerCreateOptions = {
      Image: config.image,
      name: containerName,
      Tty: false,
      OpenStdin: true,
      StdinOnce: false,

      // Keep container running for exec commands
      Cmd: ["sleep", "infinity"],

      WorkingDir: "/workspace",

      Env: env,

      HostConfig: {
        // Resource limits
        Memory: config.memoryBytes,
        MemorySwap: config.memoryBytes, // Same as Memory = no swap
        CpuShares: config.cpuShares ?? 512,

        // Network isolation
        NetworkMode: config.network,

        // Volume mounts
        Binds: mounts.map(
          (m) => `${m.hostPath}:${m.containerPath}:${m.mode}`
        ),

        // Security hardening
        SecurityOpt: ["no-new-privileges:true"],
        CapDrop: ["ALL"],
        ReadonlyRootfs: false, // Claude needs to write temp files

        // Cleanup
        AutoRemove: config.ephemeral,
      },

      // Non-root user
      User: config.user,
    };

    return this.docker.createContainer(createOptions);
  }

  /**
   * Execute a command inside a container
   *
   * @param container - Docker container
   * @param command - Command and arguments
   * @param workDir - Working directory inside container
   * @returns Exec instance for stream access
   */
  async execInContainer(
    container: Container,
    command: string[],
    workDir: string = "/workspace"
  ): Promise<Docker.Exec> {
    return container.exec({
      Cmd: command,
      AttachStdout: true,
      AttachStderr: true,
      AttachStdin: false,
      Tty: false,
      WorkingDir: workDir,
    });
  }

  /**
   * Clean up old containers for an agent
   *
   * Removes oldest containers when count exceeds maxContainers.
   *
   * @param agentName - Name of the agent
   * @param maxContainers - Maximum containers to keep
   */
  async cleanupOldContainers(
    agentName: string,
    maxContainers: number
  ): Promise<void> {
    const containers = await this.docker.listContainers({
      all: true,
      filters: {
        name: [`herdctl-${agentName}-`],
      },
    });

    // Sort by creation time, oldest first
    const sorted = containers.sort((a, b) => a.Created - b.Created);

    // Remove oldest until under limit
    const toRemove = sorted.slice(0, Math.max(0, sorted.length - maxContainers));

    for (const info of toRemove) {
      const container = this.docker.getContainer(info.Id);
      try {
        await container.remove({ force: true });
      } catch {
        // Ignore errors for already-removed containers
      }
    }
  }

  /**
   * Stop and remove a specific container
   */
  async stopContainer(container: Container): Promise<void> {
    try {
      await container.stop({ t: 5 }); // 5 second timeout
    } catch {
      // Container may already be stopped
    }

    try {
      const info = await container.inspect();
      if (!info.HostConfig?.AutoRemove) {
        await container.remove({ force: true });
      }
    } catch {
      // Container may already be removed
    }
  }
}

/**
 * Build volume mounts for container execution
 *
 * Creates mounts for workspace, auth files, and Docker sessions.
 *
 * @param agent - Resolved agent configuration
 * @param dockerConfig - Docker configuration
 * @param stateDir - herdctl state directory (.herdctl/)
 * @returns Array of path mappings
 */
export function buildContainerMounts(
  agent: ResolvedAgent,
  dockerConfig: DockerConfig,
  stateDir: string
): PathMapping[] {
  const mounts: PathMapping[] = [];

  // Workspace mount
  const workspace = agent.workspace;
  if (workspace) {
    const workspaceRoot =
      typeof workspace === "string" ? workspace : workspace.root;
    mounts.push({
      hostPath: workspaceRoot,
      containerPath: "/workspace",
      mode: dockerConfig.workspaceMode,
    });
  }

  // Auth file mount (read-only) - always mount for CLI runtime compatibility
  // Both env var (preferred) and mounted auth file are supported simultaneously
  const claudeConfigDir = path.join(os.homedir(), ".claude");
  mounts.push({
    hostPath: claudeConfigDir,
    containerPath: "/home/claude/.claude",
    mode: "ro",
  });

  // Docker sessions directory (separate from host sessions)
  const dockerSessionsDir = path.join(stateDir, "docker-sessions");
  mounts.push({
    hostPath: dockerSessionsDir,
    containerPath: "/home/claude/.herdctl/sessions",
    mode: "rw",
  });

  // Custom volumes from config
  mounts.push(...dockerConfig.volumes);

  return mounts;
}

/**
 * Build environment variables for container
 *
 * @param agent - Resolved agent configuration
 * @returns Array of "KEY=value" strings
 */
export function buildContainerEnv(agent: ResolvedAgent): string[] {
  const env: string[] = [];

  // Pass through API key if available (preferred over mounted auth)
  if (process.env.ANTHROPIC_API_KEY) {
    env.push(`ANTHROPIC_API_KEY=${process.env.ANTHROPIC_API_KEY}`);
  }

  // Terminal support
  env.push("TERM=xterm-256color");

  // HOME directory for claude user
  env.push("HOME=/home/claude");

  return env;
}
```
  </action>
  <verify>
Run `pnpm build` from packages/core - container-manager.ts should compile.
Verify dockerode is installed in package.json.
  </verify>
  <done>
container-manager.ts exports ContainerManager class, buildContainerMounts(), and buildContainerEnv().
  </done>
</task>

<task type="auto">
  <name>Task 2: Create container-runner.ts decorator</name>
  <files>packages/core/src/runner/runtime/container-runner.ts</files>
  <action>
Create the ContainerRunner decorator that implements RuntimeInterface.

```typescript
/**
 * ContainerRunner - Docker container decorator for RuntimeInterface
 *
 * Wraps any runtime (SDK or CLI) and transparently executes inside Docker containers.
 * Handles path translation, mount configuration, and container lifecycle.
 *
 * @example
 * ```typescript
 * const baseRuntime = new CLIRuntime();
 * const dockerRuntime = new ContainerRunner(baseRuntime, dockerConfig);
 *
 * // Execution happens inside Docker container
 * for await (const message of dockerRuntime.execute(options)) {
 *   console.log(message);
 * }
 * ```
 */

import Docker from "dockerode";
import { PassThrough } from "node:stream";
import { createInterface } from "node:readline";
import * as path from "node:path";
import * as fs from "node:fs/promises";
import type { RuntimeInterface, RuntimeExecuteOptions } from "./interface.js";
import type { SDKMessage } from "../types.js";
import type { DockerConfig } from "./docker-config.js";
import {
  ContainerManager,
  buildContainerMounts,
  buildContainerEnv,
} from "./container-manager.js";
import { parseCLILine } from "./cli-output-parser.js";

/**
 * Container runtime decorator
 *
 * Decorates any RuntimeInterface to execute inside Docker containers.
 * The wrapped runtime's execute logic runs via `docker exec` inside the container.
 */
export class ContainerRunner implements RuntimeInterface {
  private manager: ContainerManager;
  private stateDir: string;

  /**
   * Create a new ContainerRunner
   *
   * @param wrapped - The underlying runtime to execute inside containers
   * @param config - Docker configuration
   * @param stateDir - herdctl state directory (.herdctl/)
   * @param docker - Optional Docker client for testing
   */
  constructor(
    private wrapped: RuntimeInterface,
    private config: DockerConfig,
    stateDir: string,
    docker?: Docker
  ) {
    this.manager = new ContainerManager(docker);
    this.stateDir = stateDir;
  }

  /**
   * Execute agent inside Docker container
   *
   * Creates or reuses container, translates paths, and streams output.
   */
  async *execute(options: RuntimeExecuteOptions): AsyncIterable<SDKMessage> {
    const { agent } = options;

    // Ensure docker-sessions directory exists
    const dockerSessionsDir = path.join(this.stateDir, "docker-sessions");
    await fs.mkdir(dockerSessionsDir, { recursive: true });

    // Build mounts and environment
    const mounts = buildContainerMounts(agent, this.config, this.stateDir);
    const env = buildContainerEnv(agent);

    // Get or create container
    const container = await this.manager.getOrCreateContainer(
      agent.name,
      this.config,
      mounts,
      env
    );

    try {
      // Build the claude command for container execution
      const claudeCommand = this.buildClaudeCommand(options);

      // Execute claude inside container
      const exec = await this.manager.execInContainer(
        container,
        claudeCommand,
        "/workspace"
      );

      // Start exec and get stream
      const stream = await exec.start({ hijack: true, stdin: false });

      // Demultiplex stdout/stderr
      const stdout = new PassThrough();
      const stderr = new PassThrough();
      container.modem.demuxStream(stream, stdout, stderr);

      // Parse stdout line-by-line
      const rl = createInterface({
        input: stdout,
        crlfDelay: Infinity,
      });

      // Stream messages
      for await (const line of rl) {
        const message = parseCLILine(line);
        if (message) {
          yield message;
        }
      }

      // Check exec exit code
      const inspectData = await exec.inspect();
      if (inspectData.ExitCode !== 0) {
        yield {
          type: "error",
          error: {
            message: `Container execution failed with exit code ${inspectData.ExitCode}`,
          },
        } as SDKMessage;
      }

      // Cleanup old containers
      await this.manager.cleanupOldContainers(agent.name, this.config.maxContainers);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);

      yield {
        type: "error",
        error: {
          message: `Docker execution failed: ${errorMessage}`,
        },
      } as SDKMessage;

      // If container startup failed, try to clean up
      if (this.config.ephemeral) {
        try {
          await this.manager.stopContainer(container);
        } catch {
          // Ignore cleanup errors
        }
      }
    }
  }

  /**
   * Build claude CLI command for container execution
   *
   * Translates options to CLI arguments for execution inside container.
   */
  private buildClaudeCommand(options: RuntimeExecuteOptions): string[] {
    const { prompt, resume, fork } = options;

    const args: string[] = [
      "claude",
      "-p",
      prompt,
      "--output-format",
      "stream-json",
      "--verbose",
      "--dangerously-skip-permissions",
    ];

    // Add session resume options
    if (resume) {
      args.push("--resume", resume);
    }

    if (fork) {
      args.push("--fork-session");
    }

    return args;
  }
}
```
  </action>
  <verify>
Run `pnpm build` from packages/core - container-runner.ts should compile.
Verify ContainerRunner implements RuntimeInterface.
  </verify>
  <done>
container-runner.ts exports ContainerRunner class implementing RuntimeInterface that wraps any runtime and executes inside Docker containers.
  </done>
</task>

<task type="auto">
  <name>Task 3: Export container classes from runtime module</name>
  <files>packages/core/src/runner/runtime/index.ts</files>
  <action>
Add exports for ContainerRunner and ContainerManager to the runtime barrel file.

Add to packages/core/src/runner/runtime/index.ts:

```typescript
// Container execution
export { ContainerRunner } from "./container-runner.js";
export {
  ContainerManager,
  buildContainerMounts,
  buildContainerEnv,
} from "./container-manager.js";
```

Ensure the exports are added after the docker-config exports from Plan 01.
  </action>
  <verify>
Run `pnpm build` from packages/core - should compile and export ContainerRunner.
Run `pnpm typecheck` - no type errors.
  </verify>
  <done>
ContainerRunner and ContainerManager are exported from the runtime module.
  </done>
</task>

</tasks>

<verification>
After all tasks:

1. `pnpm build` in packages/core succeeds
2. `pnpm typecheck` succeeds
3. dockerode is in package.json dependencies
4. ContainerRunner implements RuntimeInterface
5. ContainerManager handles container lifecycle
6. buildContainerMounts creates correct mounts for workspace, auth, and sessions
7. buildContainerEnv passes ANTHROPIC_API_KEY when available
8. Runtime module re-exports ContainerRunner and ContainerManager
</verification>

<success_criteria>
- ContainerRunner wraps any RuntimeInterface and executes via docker exec
- Containers mount workspace (configurable rw/ro), auth files (read-only), and docker-sessions (rw)
- Containers use security hardening: no-new-privileges, CAP_DROP ALL, non-root user
- Container cleanup removes oldest when exceeding max_containers limit
- All code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-docker-integration/03-02-SUMMARY.md`
</output>
