---
phase: 03-docker-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/config/schema.ts
  - packages/core/src/runner/runtime/docker-config.ts
autonomous: true

must_haves:
  truths:
    - "DockerSchema validates all docker options with clear error messages"
    - "Agent config accepts docker.enabled, docker.ephemeral, docker.network, docker.memory, docker.user fields"
    - "Invalid docker configurations are rejected with helpful error messages"
  artifacts:
    - path: "packages/core/src/runner/runtime/docker-config.ts"
      provides: "Docker configuration types and validation"
      exports: ["DockerConfig", "NetworkMode", "PathMapping"]
    - path: "packages/core/src/config/schema.ts"
      provides: "Extended DockerSchema with all options"
      contains: "DockerSchema = z.object"
  key_links:
    - from: "packages/core/src/config/schema.ts"
      to: "packages/core/src/runner/runtime/docker-config.ts"
      via: "Type consistency for docker configuration"
      pattern: "docker.*enabled|ephemeral|network|memory"
---

<objective>
Extend Docker configuration schema with full options for container lifecycle, security, and resource limits.

Purpose: The ContainerRunner (Plan 02) needs typed configuration for all Docker options. This plan establishes the schema foundation that enables validation of docker.enabled, docker.ephemeral, docker.network, docker.memory, docker.user, and other options.

Output: Extended DockerSchema in config/schema.ts and new docker-config.ts with TypeScript types and helpers.
</objective>

<execution_context>
@/Users/ed/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ed/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-docker-integration/03-CONTEXT.md
@.planning/phases/03-docker-integration/03-RESEARCH.md
@packages/core/src/config/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend DockerSchema with full configuration options</name>
  <files>packages/core/src/config/schema.ts</files>
  <action>
Replace the minimal DockerSchema with a comprehensive schema supporting all Docker options.

Current DockerSchema (lines ~145-149):
```typescript
export const DockerSchema = z.object({
  enabled: z.boolean().optional().default(false),
  base_image: z.string().optional(),
});
```

Replace with comprehensive schema:

```typescript
/**
 * Network isolation modes for Docker containers
 * - "none": No network access (most secure, rare use case)
 * - "bridge": Standard Docker networking with NAT (default)
 * - "host": Share host network namespace (least isolated)
 */
export const DockerNetworkModeSchema = z.enum(["none", "bridge", "host"]);

/**
 * Docker container configuration schema
 *
 * Supports container lifecycle, resource limits, and security options.
 * All options are optional - defaults provide secure, sensible configuration.
 *
 * @example
 * ```yaml
 * docker:
 *   enabled: true
 *   ephemeral: false        # Reuse container across jobs
 *   image: anthropic/claude-code:latest
 *   network: bridge         # Full network access
 *   memory: 2g              # Memory limit
 *   cpu_shares: 512         # CPU weight
 *   user: "1000:1000"       # Run as specific UID:GID
 *   max_containers: 5       # Keep last 5 containers per agent
 *   volumes:                # Additional volume mounts
 *     - "/host/data:/container/data:ro"
 * ```
 */
export const DockerSchema = z.object({
  /** Enable Docker containerization for this agent (default: false) */
  enabled: z.boolean().optional().default(false),

  /** Use ephemeral containers (fresh per job, auto-removed) vs persistent (reuse across jobs, kept for inspection) */
  ephemeral: z.boolean().optional().default(false),

  /** Docker image to use (default: anthropic/claude-code:latest) */
  image: z.string().optional(),

  /** Network isolation mode (default: bridge for full network access) */
  network: DockerNetworkModeSchema.optional().default("bridge"),

  /** Memory limit (e.g., "2g", "512m") (default: 2g) */
  memory: z.string().optional().default("2g"),

  /** CPU shares (relative weight, 512 is normal) */
  cpu_shares: z.number().int().positive().optional(),

  /** Container user as "UID:GID" string (default: match host user) */
  user: z.string().optional(),

  /** Maximum containers to keep per agent before cleanup (default: 5) */
  max_containers: z.number().int().positive().optional().default(5),

  /** Additional volume mounts in Docker format: "host:container:mode" */
  volumes: z.array(z.string()).optional(),

  /** Workspace mount mode: rw (read-write, default) or ro (read-only) */
  workspace_mode: z.enum(["rw", "ro"]).optional().default("rw"),

  /** @deprecated Use 'image' instead */
  base_image: z.string().optional(),
});
```

Also update the Docker type export at the bottom of the file to match the new schema.

Add validation refinements:
1. Memory format validation (must match pattern like "2g", "512m", "1024k")
2. Volume mount format validation (must be "host:container" or "host:container:mode")
3. User format validation (must be "UID" or "UID:GID")

Use z.refine() for complex validation with clear error messages.
  </action>
  <verify>
Run `pnpm build` from packages/core - should compile without errors.
Run `pnpm typecheck` - DockerSchema should export new fields.
  </verify>
  <done>
DockerSchema includes enabled, ephemeral, image, network, memory, cpu_shares, user, max_containers, volumes, workspace_mode fields with defaults and validation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create docker-config.ts with TypeScript types and helpers</name>
  <files>packages/core/src/runner/runtime/docker-config.ts</files>
  <action>
Create a new file for Docker-specific TypeScript types and utility functions.

```typescript
/**
 * Docker configuration types and utilities
 *
 * This module provides TypeScript types for Docker container configuration
 * and utility functions for path mapping and container management.
 */

import type { Docker } from "../../config/schema.js";

/**
 * Network isolation modes for Docker containers
 */
export type NetworkMode = "none" | "bridge" | "host";

/**
 * Volume mount mode
 */
export type VolumeMode = "ro" | "rw";

/**
 * Path mapping between host and container
 */
export interface PathMapping {
  /** Absolute path on the host system */
  hostPath: string;
  /** Path inside the container */
  containerPath: string;
  /** Mount mode: read-only or read-write */
  mode: VolumeMode;
}

/**
 * Resolved Docker configuration with defaults applied
 */
export interface DockerConfig {
  /** Whether Docker is enabled */
  enabled: boolean;
  /** Use ephemeral containers (fresh per job) vs persistent (reuse across jobs) */
  ephemeral: boolean;
  /** Docker image to use */
  image: string;
  /** Network isolation mode */
  network: NetworkMode;
  /** Memory limit in bytes */
  memoryBytes: number;
  /** CPU shares (relative weight) */
  cpuShares?: number;
  /** Container user as "UID:GID" string */
  user: string;
  /** Maximum containers to keep per agent */
  maxContainers: number;
  /** Additional volume mounts */
  volumes: PathMapping[];
  /** Workspace mount mode */
  workspaceMode: VolumeMode;
}

/**
 * Default Docker image for Claude Code containers
 */
export const DEFAULT_DOCKER_IMAGE = "anthropic/claude-code:latest";

/**
 * Default memory limit (2GB)
 */
export const DEFAULT_MEMORY_LIMIT = "2g";

/**
 * Default max containers to keep per agent
 */
export const DEFAULT_MAX_CONTAINERS = 5;

/**
 * Parse memory string (e.g., "2g", "512m") to bytes
 *
 * @param memory - Memory string with unit suffix
 * @returns Memory in bytes
 * @throws Error if format is invalid
 */
export function parseMemoryToBytes(memory: string): number {
  const match = memory.toLowerCase().match(/^(\d+(?:\.\d+)?)\s*([kmgt]?)b?$/i);
  if (!match) {
    throw new Error(
      `Invalid memory format: "${memory}". Use format like "2g", "512m", "1024k", or "2048" (bytes).`
    );
  }

  const value = parseFloat(match[1]);
  const unit = match[2]?.toLowerCase() ?? "";

  const multipliers: Record<string, number> = {
    "": 1,
    k: 1024,
    m: 1024 * 1024,
    g: 1024 * 1024 * 1024,
    t: 1024 * 1024 * 1024 * 1024,
  };

  return Math.floor(value * multipliers[unit]);
}

/**
 * Parse volume mount string to PathMapping
 *
 * @param volume - Volume mount string in format "host:container" or "host:container:mode"
 * @returns PathMapping object
 * @throws Error if format is invalid
 */
export function parseVolumeMount(volume: string): PathMapping {
  const parts = volume.split(":");

  if (parts.length < 2 || parts.length > 3) {
    throw new Error(
      `Invalid volume format: "${volume}". Use "host:container" or "host:container:ro|rw".`
    );
  }

  const [hostPath, containerPath, modeStr] = parts;
  const mode: VolumeMode =
    modeStr === "ro" ? "ro" : modeStr === "rw" || !modeStr ? "rw" : "rw";

  if (modeStr && modeStr !== "ro" && modeStr !== "rw") {
    throw new Error(
      `Invalid volume mode: "${modeStr}". Use "ro" (read-only) or "rw" (read-write).`
    );
  }

  return { hostPath, containerPath, mode };
}

/**
 * Get the current user's UID:GID for container user mapping
 *
 * @returns User string in "UID:GID" format
 */
export function getHostUser(): string {
  // process.getuid() and process.getgid() are available on POSIX systems
  const uid = process.getuid?.() ?? 1000;
  const gid = process.getgid?.() ?? 1000;
  return `${uid}:${gid}`;
}

/**
 * Resolve Docker config from agent configuration
 *
 * Applies defaults and parses string values to typed equivalents.
 *
 * @param docker - Docker configuration from agent config (may be partial)
 * @returns Fully resolved DockerConfig
 */
export function resolveDockerConfig(docker?: Docker): DockerConfig {
  return {
    enabled: docker?.enabled ?? false,
    ephemeral: docker?.ephemeral ?? false,
    image: docker?.image ?? docker?.base_image ?? DEFAULT_DOCKER_IMAGE,
    network: docker?.network ?? "bridge",
    memoryBytes: parseMemoryToBytes(docker?.memory ?? DEFAULT_MEMORY_LIMIT),
    cpuShares: docker?.cpu_shares,
    user: docker?.user ?? getHostUser(),
    maxContainers: docker?.max_containers ?? DEFAULT_MAX_CONTAINERS,
    volumes: docker?.volumes?.map(parseVolumeMount) ?? [],
    workspaceMode: docker?.workspace_mode ?? "rw",
  };
}
```
  </action>
  <verify>
Run `pnpm build` from packages/core - docker-config.ts should compile.
Verify parseMemoryToBytes handles "2g", "512m", "1024k" correctly.
Verify parseVolumeMount handles "host:container" and "host:container:ro" formats.
  </verify>
  <done>
docker-config.ts exports DockerConfig type, PathMapping interface, parseMemoryToBytes(), parseVolumeMount(), getHostUser(), and resolveDockerConfig().
  </done>
</task>

<task type="auto">
  <name>Task 3: Export docker-config types from runtime module</name>
  <files>packages/core/src/runner/runtime/index.ts</files>
  <action>
Add exports for the new docker-config module to the runtime barrel file.

Add to packages/core/src/runner/runtime/index.ts:

```typescript
// Docker configuration
export {
  type DockerConfig,
  type PathMapping,
  type NetworkMode,
  type VolumeMode,
  parseMemoryToBytes,
  parseVolumeMount,
  getHostUser,
  resolveDockerConfig,
  DEFAULT_DOCKER_IMAGE,
  DEFAULT_MEMORY_LIMIT,
  DEFAULT_MAX_CONTAINERS,
} from "./docker-config.js";
```

Ensure the import path uses .js extension for ESM compatibility.
  </action>
  <verify>
Run `pnpm build` from packages/core - should compile and export docker types.
Run `pnpm typecheck` - no type errors.
  </verify>
  <done>
DockerConfig, PathMapping, and utility functions are exported from the runtime module.
  </done>
</task>

</tasks>

<verification>
After all tasks:

1. `pnpm build` in packages/core succeeds
2. `pnpm typecheck` succeeds
3. DockerSchema has all new fields: enabled, ephemeral, image, network, memory, cpu_shares, user, max_containers, volumes, workspace_mode
4. docker-config.ts exports DockerConfig, PathMapping, parseMemoryToBytes(), parseVolumeMount(), resolveDockerConfig()
5. Runtime module re-exports docker-config types
</verification>

<success_criteria>
- DockerSchema validates docker options with clear error messages for invalid formats
- Agent config can specify all docker options (enabled, ephemeral, network, memory, user, etc.)
- TypeScript types exist for DockerConfig, PathMapping, NetworkMode, VolumeMode
- Utility functions parse memory strings and volume mounts correctly
- All new code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-docker-integration/03-01-SUMMARY.md`
</output>
