---
phase: 02-cli-runtime-implementation
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - packages/core/src/runner/runtime/cli-session-watcher.ts
  - packages/core/src/runner/runtime/index.ts
autonomous: true

must_haves:
  truths:
    - "Session file changes can be watched via chokidar"
    - "File watcher debounces rapid writes to prevent partial reads"
    - "Session file content can be parsed to SDKMessage stream"
  artifacts:
    - path: "packages/core/src/runner/runtime/cli-session-watcher.ts"
      provides: "Session file watcher utility"
      exports: ["CLISessionWatcher", "watchSessionFile"]
      min_lines: 60
  key_links:
    - from: "cli-session-watcher.ts"
      to: "chokidar"
      via: "file watching"
      pattern: "chokidar\\.watch"
    - from: "cli-session-watcher.ts"
      to: "cli-output-parser.ts"
      via: "message parsing"
      pattern: "import.*parseCLILine.*from.*cli-output-parser"
---

<objective>
Create session file watcher utility using chokidar for monitoring CLI session files with proper debouncing.

Purpose: Provide file-based message streaming as an alternative to stdout streaming, useful for session resume scenarios and robustness.

Output: CLISessionWatcher class that watches session JSONL files and yields SDKMessages as they're written.
</objective>

<execution_context>
@/Users/ed/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ed/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-cli-runtime-implementation/02-RESEARCH.md
@.planning/phases/02-cli-runtime-implementation/02-01-SUMMARY.md
@packages/core/src/runner/runtime/cli-output-parser.ts
@packages/core/src/runner/runtime/cli-session-path.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session file watcher</name>
  <files>packages/core/src/runner/runtime/cli-session-watcher.ts</files>
  <action>
Create cli-session-watcher.ts that monitors CLI session files and emits parsed messages.

Use chokidar with awaitWriteFinish to handle atomic writes (from research):

```typescript
import chokidar from 'chokidar';
import { readFile } from 'fs/promises';
import type { SDKMessage } from '../types.js';
import { parseCLILine } from './cli-output-parser.js';
```

Implementation requirements:

1. Create CLISessionWatcher class:
```typescript
export class CLISessionWatcher {
  private watcher: chokidar.FSWatcher | null = null;
  private lastLineCount = 0;
  private sessionFilePath: string;

  constructor(sessionFilePath: string) {
    this.sessionFilePath = sessionFilePath;
  }

  // Start watching and yield new messages
  async *watch(): AsyncIterable<SDKMessage> {
    // Implementation
  }

  // Stop watching
  stop(): void {
    this.watcher?.close();
    this.watcher = null;
  }
}
```

2. Configure chokidar with debouncing:
```typescript
this.watcher = chokidar.watch(this.sessionFilePath, {
  awaitWriteFinish: {
    stabilityThreshold: 500,  // Wait 500ms after last write
    pollInterval: 100,
  },
});
```

3. On file change:
   - Read entire file content
   - Split into lines
   - Skip lines already processed (tracked by lastLineCount)
   - Parse new lines with parseCLILine
   - Yield valid messages

4. Handle initial state:
   - If file exists when watch starts, read and process existing content
   - Track starting line count for incremental processing

5. Create helper function:
```typescript
export async function* watchSessionFile(
  sessionFilePath: string,
  signal?: AbortSignal
): AsyncIterable<SDKMessage> {
  const watcher = new CLISessionWatcher(sessionFilePath);
  try {
    for await (const message of watcher.watch()) {
      if (signal?.aborted) break;
      yield message;
    }
  } finally {
    watcher.stop();
  }
}
```

Add JSDoc explaining:
- This is an alternative to stdout streaming for CLI output
- Uses chokidar's awaitWriteFinish to prevent partial JSON reads
- Useful for session replay and robust message capture
  </action>
  <verify>
- `pnpm build --filter @herdctl/core` compiles successfully
- `grep "chokidar.watch" packages/core/src/runner/runtime/cli-session-watcher.ts` confirms chokidar usage
- `grep "awaitWriteFinish" packages/core/src/runner/runtime/cli-session-watcher.ts` confirms debouncing
  </verify>
  <done>
CLISessionWatcher class watches session files with chokidar, uses awaitWriteFinish for debouncing, and yields parsed SDKMessages
  </done>
</task>

<task type="auto">
  <name>Task 2: Update barrel exports</name>
  <files>packages/core/src/runner/runtime/index.ts</files>
  <action>
Add exports for the session watcher utilities.

Add to existing exports:
```typescript
export { CLISessionWatcher, watchSessionFile } from './cli-session-watcher.js';
```

This makes the file watching capability available for advanced use cases like:
- Session replay
- Alternative message source for robustness
- Debugging/logging CLI sessions
  </action>
  <verify>
- `pnpm build --filter @herdctl/core` compiles successfully
- `grep "CLISessionWatcher" packages/core/src/runner/runtime/index.ts` shows export
  </verify>
  <done>
CLISessionWatcher and watchSessionFile exported from runtime module
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pnpm build --filter @herdctl/core` passes
2. `pnpm typecheck --filter @herdctl/core` passes
3. CLISessionWatcher can be imported from '@herdctl/core'
4. File watching uses chokidar with awaitWriteFinish debouncing
</verification>

<success_criteria>
- CLISessionWatcher watches session files via chokidar
- awaitWriteFinish with 500ms stabilityThreshold prevents partial reads
- Session file content parsed to SDKMessage stream
- Exports available from runtime module
</success_criteria>

<output>
After completion, create `.planning/phases/02-cli-runtime-implementation/02-03-SUMMARY.md`
</output>
