---
phase: 02-cli-runtime-implementation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - packages/core/src/runner/runtime/cli-runtime.ts
  - packages/core/src/runner/runtime/factory.ts
  - packages/core/src/runner/runtime/index.ts
autonomous: true

must_haves:
  truths:
    - "Agent with runtime: 'cli' spawns claude command via execa"
    - "CLI stdout streams as SDKMessage to caller"
    - "Session ID is captured from init message for resume support"
    - "Process termination yields appropriate result message"
    - "AbortController cancels the subprocess"
  artifacts:
    - path: "packages/core/src/runner/runtime/cli-runtime.ts"
      provides: "CLIRuntime implementing RuntimeInterface"
      exports: ["CLIRuntime"]
      min_lines: 80
    - path: "packages/core/src/runner/runtime/factory.ts"
      provides: "RuntimeFactory with CLI support"
      contains: "new CLIRuntime"
    - path: "packages/core/src/runner/runtime/index.ts"
      provides: "Barrel exports including CLIRuntime"
      exports: ["CLIRuntime"]
  key_links:
    - from: "cli-runtime.ts"
      to: "cli-output-parser.ts"
      via: "parseCLILine import"
      pattern: "import.*parseCLILine.*from.*cli-output-parser"
    - from: "cli-runtime.ts"
      to: "execa"
      via: "process spawning"
      pattern: "execa\\("
    - from: "factory.ts"
      to: "cli-runtime.ts"
      via: "CLIRuntime instantiation"
      pattern: "new CLIRuntime\\(\\)"
---

<objective>
Implement CLIRuntime class that executes Claude via the CLI instead of the SDK, enabling Max plan pricing for agents.

Purpose: Allow agents to run on CLI backend (Max plan) while maintaining identical SDKMessage streaming interface used by SDKRuntime.

Output: Working CLIRuntime class, updated RuntimeFactory supporting 'cli' type, exports updated.
</objective>

<execution_context>
@/Users/ed/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ed/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-cli-runtime-implementation/02-RESEARCH.md
@.planning/phases/02-cli-runtime-implementation/02-01-SUMMARY.md
@packages/core/src/runner/runtime/interface.ts
@packages/core/src/runner/runtime/sdk-runtime.ts
@packages/core/src/runner/runtime/factory.ts
@packages/core/src/runner/runtime/cli-output-parser.ts
@packages/core/src/runner/runtime/cli-session-path.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CLIRuntime class</name>
  <files>packages/core/src/runner/runtime/cli-runtime.ts</files>
  <action>
Create cli-runtime.ts implementing RuntimeInterface for CLI-based execution.

Use the pattern from research - spawn claude with stream-json output and parse stdout:

```typescript
import { execa } from 'execa';
import type { RuntimeInterface, RuntimeExecuteOptions } from './interface.js';
import type { SDKMessage } from '../types.js';
import { parseCLILine } from './cli-output-parser.js';
```

Implementation requirements:

1. Class structure:
```typescript
export class CLIRuntime implements RuntimeInterface {
  async *execute(options: RuntimeExecuteOptions): AsyncIterable<SDKMessage> {
    // Implementation
  }
}
```

2. Build CLI arguments array:
   - `-p`, options.prompt (the prompt to send)
   - `--output-format`, `stream-json` (JSONL streaming output)
   - `--verbose` (required with stream-json for full output)
   - `--dangerously-skip-permissions` (required for headless execution)
   - If options.resume: add `--resume`, options.resume
   - If options.fork: add `--fork-session`

3. Spawn process with execa:
```typescript
const subprocess = execa('claude', args, {
  cwd: options.agent.workspace?.root,
  cancelSignal: options.abortController?.signal,
});
```

4. Stream stdout and parse:
   - Use readline or async iteration over subprocess.stdout
   - For each line, call parseCLILine()
   - If parseCLILine returns a message, yield it
   - Track session_id from first message with session_id field

5. Handle process completion:
   - After subprocess completes, check exit code
   - If non-zero and no error message yielded, yield synthetic error message

6. Error handling:
   - Catch execa errors (ENOENT for missing claude command)
   - Yield error SDKMessage with helpful message ("claude command not found" etc)

Add JSDoc comments explaining:
- This runtime uses Claude CLI instead of SDK
- Requires claude CLI to be installed and authenticated
- Uses Max plan pricing when executed via CLI
  </action>
  <verify>
- `pnpm build --filter @herdctl/core` compiles successfully
- `grep "implements RuntimeInterface" packages/core/src/runner/runtime/cli-runtime.ts` confirms interface implementation
- `grep "execa" packages/core/src/runner/runtime/cli-runtime.ts` confirms execa usage
  </verify>
  <done>
CLIRuntime class exists, implements RuntimeInterface, spawns claude CLI with stream-json output, and yields parsed SDKMessage stream
  </done>
</task>

<task type="auto">
  <name>Task 2: Update RuntimeFactory to support CLI</name>
  <files>packages/core/src/runner/runtime/factory.ts</files>
  <action>
Update factory.ts to instantiate CLIRuntime when runtime type is 'cli'.

Changes:
1. Import CLIRuntime:
```typescript
import { CLIRuntime } from './cli-runtime.js';
```

2. Replace the 'cli' case that currently throws:
```typescript
case "cli":
  return new CLIRuntime();
```

3. Remove the error message about CLI being Phase 2 - it's now implemented.

The factory should now support both runtime types:
- 'sdk' -> SDKRuntime
- 'cli' -> CLIRuntime
- default -> SDKRuntime (when runtime not specified)
  </action>
  <verify>
- `pnpm build --filter @herdctl/core` compiles successfully
- `grep "new CLIRuntime" packages/core/src/runner/runtime/factory.ts` shows CLIRuntime instantiation
- `grep -v "not yet implemented" packages/core/src/runner/runtime/factory.ts` confirms error message removed
  </verify>
  <done>
RuntimeFactory.create() returns CLIRuntime for agents with runtime: 'cli'
  </done>
</task>

<task type="auto">
  <name>Task 3: Update barrel exports</name>
  <files>packages/core/src/runner/runtime/index.ts</files>
  <action>
Update index.ts to export CLIRuntime and related utilities.

Add exports:
```typescript
export { CLIRuntime } from './cli-runtime.js';
export { parseCLILine, toSDKMessage, type CLIMessage } from './cli-output-parser.js';
export { encodePathForCli, getCliSessionDir, getCliSessionFile } from './cli-session-path.js';
```

Keep existing exports (RuntimeInterface, RuntimeExecuteOptions, SDKRuntime, RuntimeFactory, RuntimeType).

The barrel export should provide clean access to all runtime-related types and classes.
  </action>
  <verify>
- `pnpm build --filter @herdctl/core` compiles successfully
- `grep "CLIRuntime" packages/core/src/runner/runtime/index.ts` shows export
- `grep "parseCLILine" packages/core/src/runner/runtime/index.ts` shows export
  </verify>
  <done>
CLIRuntime, parser functions, and session path utilities are exported from the runtime module
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pnpm build --filter @herdctl/core` passes
2. `pnpm typecheck --filter @herdctl/core` passes
3. RuntimeFactory.create() with runtime: 'cli' returns CLIRuntime instance
4. CLIRuntime can be imported from '@herdctl/core'
</verification>

<success_criteria>
- CLIRuntime implements RuntimeInterface
- CLIRuntime spawns `claude` CLI with correct flags
- CLIRuntime streams stdout as SDKMessage via parseCLILine
- RuntimeFactory returns CLIRuntime for runtime: 'cli'
- All types exported from module barrel
</success_criteria>

<output>
After completion, create `.planning/phases/02-cli-runtime-implementation/02-02-SUMMARY.md`
</output>
